<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Safe Room</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #chat-log { display: flex; flex-direction: column; gap: 0.75rem; }
        .chat-message { display: flex; flex-direction: column; max-width: 80%; word-break: break-word; }
        .message-bubble { padding: 0.5rem 1rem; border-radius: 1rem; }
        .sender-name { font-size: 0.75rem; font-weight: 600; margin-bottom: 0.25rem; }
        .message-self { align-self: flex-end; align-items: flex-end; }
        .message-self .message-bubble { background-color: #0891b2; }
        .message-peer { align-self: flex-start; align-items: flex-start; }
        .message-peer .message-bubble { background-color: #4b5563; }
        .message-system { align-self: center; text-align: center; font-size: 0.875rem; color: #9ca3af; }
        .participant-entry { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem; border-radius: 0.375rem; }
        .message-pending .status-indicator { color: #9ca3af; }
        .message-sent .status-indicator { color: #10b981; }
        .message-failed .status-indicator { color: #ef4444; }
        .message-queued .status-indicator { color: #f59e0b; }
        .message-failed .message-bubble { border-left: 3px solid #ef4444; }
        .message-queued .message-bubble { border-left: 3px solid #f59e0b; }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center min-h-screen p-4">

    <div id="host-transfer-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-2xl shadow-lg p-8 w-full max-w-md">
            <h2 class="text-2xl font-bold text-cyan-300 mb-4">Leave Room</h2>
            <p class="text-gray-300 mb-6">You are the host. You can either close the room for everyone, or promote another user to be the new host.</p>
            <div id="no-peers-message" class="hidden text-center text-gray-400 p-4 bg-gray-700 rounded-lg">You are the only one here. The room will be closed when you leave.</div>
            <div id="peer-selection-panel">
                <h3 class="font-semibold mb-3">Select a new host:</h3>
                <div id="modal-peer-list" class="space-y-2 max-h-48 overflow-y-auto bg-gray-900 p-3 rounded-lg"></div>
            </div>
            <div class="mt-8 flex justify-end space-x-4">
                <button id="close-room-btn" class="bg-gray-600 hover:bg-gray-500 text-white font-bold py-2 px-5 rounded-lg">Close Room & Leave</button>
                <button id="promote-host-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-5 rounded-lg">Promote & Leave</button>
            </div>
        </div>
    </div>

    <div class="w-full max-w-6xl mx-auto space-y-6">
        <header class="text-center">
            <h1 class="text-4xl font-bold text-cyan-400">Safe Room</h1>
            <p class="text-gray-400 mt-2">Powered by : )</p>
        </header>

        <div id="initial-view" class="max-w-2xl mx-auto w-full bg-gray-800 p-8 rounded-2xl shadow-lg">
            <h2 class="text-2xl font-bold text-center text-cyan-300 mb-6">Join or Create a Room</h2>
            <div class="space-y-4">
                <div><label for="displayName" class="block text-sm font-medium text-gray-300">Your Name:</label><input type="text" id="displayName" class="mt-1 bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-full p-2.5" placeholder="Enter your name..."></div>
                <div class="pt-4 border-t border-gray-600"><label for="roomName" class="block text-sm font-medium text-gray-300">New Room Name:</label><div class="flex space-x-2 mt-1"><input type="text" id="roomName" class="flex-grow bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-full p-2.5" placeholder="Enter a name for your new room..."><button id="createRoomBtn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2 px-5 rounded-lg">Create</button></div></div>
                <div class="pt-4 border-t border-gray-600"><div class="flex justify-between items-center mb-2"><h3 class="text-lg font-semibold text-gray-300">Available Rooms</h3><button id="refreshRoomsBtn" class="text-sm bg-gray-700 hover:bg-gray-600 py-1 px-3 rounded-lg">Refresh</button></div><div id="room-list" class="h-48 overflow-y-auto bg-gray-900 rounded-lg p-3 space-y-2"><p class="text-gray-500">No rooms available. Create one!</p></div></div>
            </div>
        </div>

        <div id="main-view" class="hidden grid lg:grid-cols-4 gap-6">
            <div class="lg:col-span-1 bg-gray-800 p-6 rounded-2xl shadow-lg flex flex-col space-y-4 h-fit">
                <div>
                    <h2 class="text-xl font-semibold text-cyan-300">Room Info</h2>
                    <p><strong>Room:</strong> <span id="current-room-name" class="font-mono"></span></p>
                    <p><strong>My Role:</strong> <span id="role" class="font-mono"></span></p>
                </div>
                <div class="pt-4 border-t border-gray-700">
                    <div class="flex justify-between items-center">
                        <h3 class="text-lg font-semibold text-gray-300">Participants (<span id="participant-count">0</span>)</h3>
                    </div>
                    <div id="participants-list" class="mt-2 space-y-1 max-h-60 overflow-y-auto"></div>
                </div>
                <div id="host-panel" class="hidden pt-4 border-t border-gray-700">
                     <h3 class="text-lg font-semibold text-gray-300">Pending Join Requests</h3>
                     <div class="mt-2 text-sm">
                        <label for="auto-accept-checkbox" class="inline-flex items-center cursor-pointer">
                            <span class="relative">
                                <input type="checkbox" id="auto-accept-checkbox" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-600 rounded-full peer peer-focus:ring-4 peer-focus:ring-cyan-800 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-cyan-600"></div>
                            </span>
                            <span class="ml-3 font-medium text-gray-300">Auto-accept requests</span>
                        </label>
                    </div>
                     <div id="pending-requests" class="mt-2 space-y-2"><p class="text-sm text-gray-500">No pending requests.</p></div>
                </div>
                <div class="flex-grow"></div>
                <button id="leave-room-btn" class="w-full bg-red-600 hover:bg-red-500 text-white font-bold py-3 px-4 rounded-lg">Leave Room</button>
            </div>
            <div class="lg:col-span-3 bg-gray-800 p-6 rounded-2xl shadow-lg flex flex-col h-[80vh]">
                <h2 class="text-2xl font-semibold mb-3 text-cyan-300">Chat</h2>
                <div id="chat-log" class="flex-grow bg-gray-900 rounded-lg p-3 overflow-y-auto mb-3 text-sm"></div>
                <div class="flex space-x-2 mt-4"><input type="text" id="chat-input" placeholder="Type a message..." class="flex-grow bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-cyan-500 focus:border-cyan-500 block w-full p-2.5" disabled><button id="send-chat-btn" class="bg-cyan-600 hover:bg-cyan-500 text-white font-bold py-2.5 px-6 rounded-lg shadow-md" disabled>Send</button></div>
            </div>
        </div>
    </div>

    <script type="module">
        // --- State Variables ---
        let myRole = 'undetermined', myName = 'Anonymous', currentRoom = '';
        let myAssignedId = null;
        let messageCounter = 0;
        let participants = {};
        const peerConnections = new Map();
        let isTransferringHost = false;
        let hostTransferData = null;
        let pendingMessages = new Map();
        let messageIdCounter = 0;
        let messageQueue = [];
        let isHostTransferInProgress = false;
        let isInitialJoinerSetupComplete = false;
        let isLeaving = false;

        // --- Constants & Initialization ---
        const SIGNALING_SERVER_URL = 'https://signal.hoko.xyz';
        const socket = io(SIGNALING_SERVER_URL, { autoConnect: false });
        const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        const DOM = {
            initialView: document.getElementById('initial-view'), mainView: document.getElementById('main-view'), displayNameInput: document.getElementById('displayName'), roomNameInput: document.getElementById('roomName'), createRoomBtn: document.getElementById('createRoomBtn'), refreshRoomsBtn: document.getElementById('refreshRoomsBtn'), roomList: document.getElementById('room-list'), currentRoomNameSpan: document.getElementById('current-room-name'), roleSpan: document.getElementById('role'), participantCount: document.getElementById('participant-count'), participantsList: document.getElementById('participants-list'), changeNameBtn: document.getElementById('change-name-btn'), hostPanel: document.getElementById('host-panel'), pendingRequestsDiv: document.getElementById('pending-requests'), leaveRoomBtn: document.getElementById('leave-room-btn'), chatLog: document.getElementById('chat-log'), chatInput: document.getElementById('chat-input'), sendChatBtn: document.getElementById('send-chat-btn'),
            hostTransferModal: document.getElementById('host-transfer-modal'), modalPeerList: document.getElementById('modal-peer-list'), noPeersMessage: document.getElementById('no-peers-message'), peerSelectionPanel: document.getElementById('peer-selection-panel'), closeRoomBtn: document.getElementById('close-room-btn'), promoteHostBtn: document.getElementById('promote-host-btn'),
            autoAcceptCheckbox: document.getElementById('auto-accept-checkbox'),
        };

        // --- Core Application Logic ---
        function switchToMainView(role, roomName) {
            myRole = role;
            currentRoom = roomName;
            myName = DOM.displayNameInput.value.trim() || 'Anonymous';
            myAssignedId = null;
            isLeaving = false; 
            if (myRole === 'host') {
                participants = { [socket.id]: { name: myName, role: 'host' } };
                messageCounter = 0;
                renderParticipantList();
            }
            if (myRole === 'joiner') {
                isInitialJoinerSetupComplete = false;
            }
            DOM.initialView.classList.add('hidden');
            DOM.mainView.classList.remove('hidden');
            DOM.roleSpan.textContent = myRole;
            DOM.currentRoomNameSpan.textContent = currentRoom;
            DOM.hostPanel.classList.toggle('hidden', myRole !== 'host');
        }

        async function createPeerConnection(peerId, peerName) {
            const pc = new RTCPeerConnection(configuration);
            peerConnections.set(peerId, { pc, dc: null, name: peerName });
            pc.onconnectionstatechange = () => updatePeerStatus(peerId, pc.connectionState);
            return pc;
        }
        
        async function createRoom() {
            const roomName = DOM.roomNameInput.value.trim();
            const userName = DOM.displayNameInput.value.trim() || 'Anonymous';
            if (!roomName || !userName) return alert('Please enter your name and a room name.');
            socket.connect();
            socket.emit('create_room', { room_name: roomName, owner_name: userName });
        }
        
        async function joinRoom(roomName) {
            const userName = DOM.displayNameInput.value.trim() || 'Anonymous';
            if (!userName) return alert('Please enter your name.');
            if (myRole === 'undetermined') switchToMainView('joiner', roomName);
            appendMessageToLog('System', 'Requesting to join the room... Please wait for the host to accept.', 'System');
            const pc = await createPeerConnection('host', 'Host');
            const iceGatheringPromise = new Promise(resolve => { pc.onicegatheringstatechange = () => (pc.iceGatheringState === 'complete') && resolve(); });
            const dc = pc.createDataChannel('chat', { negotiated: false });
            bindDataChannelEvents('host', dc);
            peerConnections.get('host').dc = dc;
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            await iceGatheringPromise;
            socket.connect();
            socket.emit('join_request', { room_name: roomName, joiner_name: userName, offer_sdp: pc.localDescription });
        }

        async function acceptJoiner(joinerSid, joinerName, offerSdp) {
            const finalName = getUniqueName(joinerName);
            const pc = await createPeerConnection(joinerSid, finalName);
            const iceGatheringPromise = new Promise(resolve => { pc.onicegatheringstatechange = () => (pc.iceGatheringState === 'complete') && resolve(); });
            pc.ondatachannel = event => {
                const peer = peerConnections.get(joinerSid);
                if (peer) {
                    peer.dc = event.channel;
                    bindDataChannelEvents(joinerSid, event.channel);
                }
            };
            await pc.setRemoteDescription(new RTCSessionDescription(offerSdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            await iceGatheringPromise;
            socket.emit('accept_joiner', { joiner_sid: joinerSid, answer_sdp: pc.localDescription, room_name: currentRoom });
            const requestEl = document.getElementById(`req-${joinerSid}`);
            if (requestEl) requestEl.remove();
            if (DOM.pendingRequestsDiv.children.length === 0) DOM.pendingRequestsDiv.innerHTML = '<p class="text-sm text-gray-500">No pending requests.</p>';
        }

        async function denyJoiner(joinerSid, joinerName) {
            socket.emit('deny_joiner', { joiner_sid: joinerSid, room_name: currentRoom });
            appendMessageToLog('System', `Denied join request from ${joinerName}.`, 'System');
            const requestEl = document.getElementById(`req-${joinerSid}`);
            if (requestEl) {
                requestEl.remove();
            }
            if (DOM.pendingRequestsDiv.children.length === 0) {
                DOM.pendingRequestsDiv.innerHTML = '<p class="text-sm text-gray-500">No pending requests.</p>';
            }
        }

        // --- Name & Participant List Management ---
        function getUniqueName(name) {
            let finalName = name;
            let i = 2;
            const existingNames = Object.values(participants).map(p => p.name);
            while (existingNames.includes(finalName)) {
                finalName = `${name}-${i}`;
                i++;
            }
            return finalName;
        }

        function broadcastParticipantList() {
            if (myRole !== 'host') return;
            const payload = JSON.stringify({ type: 'user_list_update', list: participants });
            peerConnections.forEach(peer => {
                if (peer.dc?.readyState === 'open') peer.dc.send(payload);
            });
            renderParticipantList();
        }

        function renderParticipantList() {
            DOM.participantsList.innerHTML = '';
            const userArray = Object.entries(participants);
            DOM.participantCount.textContent = userArray.length;

            userArray.sort(([, a], [, b]) => {
                if (a.role === 'host') return -1;
                if (b.role === 'host') return 1;
                return a.name.localeCompare(b.name);
            }).forEach(([id, user]) => {
                const item = document.createElement('div');
                item.className = 'participant-entry';
                const isSelf = id === socket.id || (myRole === 'joiner' && user.role === 'host' && Object.keys(participants).length === 2) || (participants[id]?.name === myName);
                const selfIndicator = isSelf ? ' (You)' : '';
                const roleIndicator = user.role === 'host' ? '<span class="text-xs font-bold text-cyan-400">[Host]</span>' : '';
                
                let editIcon = '';
                if (isSelf) {
                    editIcon = `<button onclick="window.requestNameChange('${id}')" title="Edit your name" class="text-gray-400 hover:text-white text-xs ml-2">
                        <svg width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                            <path d="M15.502 1.94a.5.5 0 0 1 0 .706L14.459 3.69l-2-2L13.502.646a.5.5 0 0 1 .707 0l1.293 1.293zm-1.75 2.456-2-2L4.939 9.21a.5.5 0 0 0-.121.196l-.805 2.414a.25.25 0 0 0 .316.316l2.414-.805a.5.5 0 0 0 .196-.12l6.813-6.814z"/>
                            <path fill-rule="evenodd" d="M1 13.5A1.5 1.5 0 0 0 2.5 15h11a1.5 1.5 0 0 0 1.5-1.5v-6a.5.5 0 0 0-1 0v6a.5.5 0 0 1-.5-.5h-11a.5.5 0 0 1-.5-.5v-11a.5.5 0 0 1 .5-.5H9a.5.5 0 0 0 0-1H2.5A1.5 1.5 0 0 0 1 2.5z"/>
                        </svg>
                    </button>`;
                }
                
                item.innerHTML = `
                    <div class="flex items-center">
                        <span class="text-sm ${isSelf ? 'font-bold' : ''}">${user.name}${selfIndicator}</span>
                        ${editIcon}
                    </div>
                    ${roleIndicator}
                `;
                DOM.participantsList.appendChild(item);
            });
        }

        function requestNameChange(userId = null) {
            const targetUserId = userId || socket.id;
            const targetUser = participants[targetUserId];
            const isSelf = targetUserId === socket.id;
            
            if (!targetUser) {
                console.error('User not found:', targetUserId);
                return;
            }
            
            const promptText = isSelf ? 
                `Enter your new name:` : 
                `Enter new name for ${targetUser.name}:`;
                
            const newName = prompt(promptText, targetUser.name);
            
            if (newName && newName.trim() !== '' && newName !== targetUser.name) {
                if (isSelf) {
                    if (myRole === 'host') {
                        const uniqueName = getUniqueName(newName);
                        participants[socket.id].name = uniqueName;
                        myName = uniqueName;
                        broadcastParticipantList();
                        appendMessageToLog('System', `You changed your name to ${uniqueName}`, 'System');
                    } else {
                        const payload = JSON.stringify({ type: 'request_name_change', newName: newName.trim() });
                        peerConnections.get('host')?.dc?.send(payload);
                        appendMessageToLog('System', `Requesting name change to ${newName.trim()}...`, 'System');
                    }
                } else if (myRole === 'host') {
                    const uniqueName = getUniqueName(newName);
                    const oldName = targetUser.name;
                    participants[targetUserId].name = uniqueName;
                    
                    const peerConnection = peerConnections.get(targetUserId);
                    if (peerConnection) {
                        peerConnection.name = uniqueName;
                    }
                    
                    broadcastParticipantList();
                    appendMessageToLog('System', `Host changed ${oldName}'s name to ${uniqueName}`, 'System');
                }
            }
        }
        
        window.requestNameChange = requestNameChange;

        // --- Host Transfer Implementation ---
        async function initiateHostTransfer(newHostSid) {
            if (myRole !== 'host') return;
            
            appendMessageToLog('System', 'Starting host transfer process...', 'System');
            isTransferringHost = true;
            
            const transferStartAnnouncement = {
                type: 'host_transfer_starting',
                newHostSid: newHostSid,
                newHostName: participants[newHostSid].name
            };
            
            peerConnections.forEach((peer, peerId) => {
                if (peer.dc?.readyState === 'open') {
                    peer.dc.send(JSON.stringify(transferStartAnnouncement));
                }
            });
            
            const newHostName = participants[newHostSid].name;
            hostTransferData = {
                newHostSid,
                newHostName,
                pendingOffers: new Map(),
                pendingAnswers: new Map(),
                expectedOffers: Object.keys(participants).filter(id => id !== socket.id && id !== newHostSid).length,
                receivedOffers: 0,
                expectedAnswers: 0,
                receivedAnswers: 0
            };
            
            const announcement = {
                type: 'host_transfer_announcement',
                newHostSid,
                newHostName,
                participants: participants
            };
            
            peerConnections.forEach((peer, peerId) => {
                if (peer.dc?.readyState === 'open') {
                    peer.dc.send(JSON.stringify(announcement));
                }
            });
            
            appendMessageToLog('System', `Transferring host role to ${newHostName}...`, 'System');
            
            if (hostTransferData.expectedOffers > 0) {
                const requestOffers = { type: 'request_new_offer_for_host_transfer' };
                peerConnections.forEach((peer, peerId) => {
                    if (peerId !== newHostSid && peer.dc?.readyState === 'open') {
                        peer.dc.send(JSON.stringify(requestOffers));
                    }
                });
            } else {
                completeHostTransferDirectly();
            }
        }
        
        async function handleOfferFromPeer(fromPeerId, offerSdp) {
            if (!isTransferringHost || !hostTransferData) return;
            
            console.log(`Received offer from ${fromPeerId} for host transfer`);
            hostTransferData.pendingOffers.set(fromPeerId, offerSdp);
            hostTransferData.receivedOffers++;
            
            const newHostPeer = peerConnections.get(hostTransferData.newHostSid);
            if (newHostPeer?.dc?.readyState === 'open') {
                const forwardOffer = {
                    type: 'forwarded_offer_for_host_transfer',
                    fromPeerId,
                    fromPeerName: participants[fromPeerId]?.name || 'Unknown',
                    offerSdp
                };
                newHostPeer.dc.send(JSON.stringify(forwardOffer));
                hostTransferData.expectedAnswers++;
            }
            
            if (hostTransferData.receivedOffers >= hostTransferData.expectedOffers) {
                console.log('All offers received, waiting for answers...');
            }
        }
        
        async function handleAnswerFromNewHost(forPeerId, answerSdp) {
            if (!isTransferringHost || !hostTransferData) return;
            
            console.log(`Received answer from new host for ${forPeerId}`);
            hostTransferData.pendingAnswers.set(forPeerId, answerSdp);
            hostTransferData.receivedAnswers++;
            
            const targetPeer = peerConnections.get(forPeerId);
            if (targetPeer?.dc?.readyState === 'open') {
                const forwardAnswer = {
                    type: 'forwarded_answer_for_host_transfer',
                    answerSdp
                };
                targetPeer.dc.send(JSON.stringify(forwardAnswer));
            }
            
            if (hostTransferData.receivedAnswers >= hostTransferData.expectedAnswers) {
                console.log('All answers received, completing transfer...');
                completeHostTransfer();
            }
        }
        
        async function completeHostTransferDirectly() {
            console.log('Completing direct host transfer...');
            
            const newHostPeer = peerConnections.get(hostTransferData.newHostSid);
            if (newHostPeer?.dc?.readyState === 'open') {
                const transferMessage = {
                    type: 'host_transfer_complete',
                    roomName: currentRoom,
                    participants: participants
                };
                newHostPeer.dc.send(JSON.stringify(transferMessage));
            }
            
            finalizeHostTransfer();
        }
        
        async function completeHostTransfer() {
            if (!isTransferringHost || !hostTransferData) return;
            
            console.log('Completing host transfer...');
            
            const newHostPeer = peerConnections.get(hostTransferData.newHostSid);
            if (newHostPeer?.dc?.readyState === 'open') {
                const transferMessage = {
                    type: 'host_transfer_complete',
                    roomName: currentRoom,
                    participants: participants
                };
                newHostPeer.dc.send(JSON.stringify(transferMessage));
            }
            
            peerConnections.forEach((peer, peerId) => {
                if (peerId !== hostTransferData.newHostSid && peer.dc?.readyState === 'open') {
                    const completeMessage = {
                        type: 'host_transfer_finalized',
                        newHostName: hostTransferData.newHostName
                    };
                    peer.dc.send(JSON.stringify(completeMessage));
                }
            });
            
            setTimeout(() => finalizeHostTransfer(), 200);
        }
        
        async function finalizeHostTransfer() {
            if (!hostTransferData) return;
            
            appendMessageToLog('System', 'Host transfer completed. Disconnecting...', 'System');
            
            const updatedParticipants = { ...participants };
            delete updatedParticipants[socket.id];
            
            const finalUpdate = {
                type: 'final_participant_update',
                participants: updatedParticipants,
                oldHostLeft: true
            };
            
            peerConnections.forEach((peer, peerId) => {
                if (peer.dc?.readyState === 'open') {
                    peer.dc.send(JSON.stringify(finalUpdate));
                }
            });
            
            setTimeout(() => {
                console.log('Old host: Closing all connections and leaving...');
                
                peerConnections.forEach((peer, peerId) => {
                    peer.pc.close();
                });
                
                peerConnections.clear();
                socket.disconnect();
                gracefulDisconnect();
            }, 200);
        }
        
        async function handleHostTransferComplete(roomName, transferredParticipants) {
            console.log('🔄 Host transfer complete, becoming new host...');

            const setupNewHost = () => {
                console.log(`Socket connected with new ID: ${socket.id}. Setting up as host.`);

                myRole = 'host';
                participants = transferredParticipants;

                let myOldId = null;
                for (const id in participants) {
                    if (participants[id].name === myName && participants[id].role !== 'host') {
                        myOldId = id;
                        break;
                    }
                }
                if (myOldId) {
                    console.log(`Found and removing my old participant entry (ID: ${myOldId})`);
                    delete participants[myOldId];
                }

                let oldHostRemoved = false;
                Object.keys(participants).forEach(id => {
                    if (participants[id].role === 'host') {
                        delete participants[id];
                        oldHostRemoved = true;
                    }
                });

                participants[socket.id] = { name: myName, role: 'host' };

                DOM.roleSpan.textContent = 'host';
                DOM.hostPanel.classList.remove('hidden');

                appendMessageToLog('System', 'You are now the host!', 'System');
                if (oldHostRemoved) {
                    appendMessageToLog('System', 'Previous host has left the room.', 'System');
                }

                const oldHostPeer = peerConnections.get('host');
                if (oldHostPeer) {
                    console.log('New host: Closing and removing old host connection');
                    oldHostPeer.pc.close();
                    peerConnections.delete('host');
                }

                broadcastParticipantList();

                socket.emit('claim_room_ownership', {
                    room_name: roomName,
                    new_host_name: myName
                });

                enableChat(true);
                isHostTransferInProgress = false;

                setTimeout(() => {
                    notifyTransferCompletion();
                }, 2000);
            };

            if (socket.connected && socket.id) {
                setupNewHost();
            } else {
                socket.once('connect', setupNewHost);
                if (!socket.connecting && !socket.connected) {
                    socket.connect();
                }
            }
        }
        
        function notifyTransferCompletion() {
            const transferCompleteNotification = {
                type: 'host_transfer_completed',
                newHostName: myName
            };
            
            let notificationsSent = 0;
            let totalPeers = 0;
            
            peerConnections.forEach((peer, peerId) => {
                totalPeers++;
                if (peer.dc?.readyState === 'open') {
                    try {
                        peer.dc.send(JSON.stringify(transferCompleteNotification));
                        notificationsSent++;
                    } catch (error) {
                        console.error(`❌ Failed to send completion notification to ${peerId}:`, error);
                    }
                } else {
                    if (peer.dc?.readyState === 'connecting') {
                        const originalOnOpen = peer.dc.onopen;
                        peer.dc.onopen = (event) => {
                            if (originalOnOpen) originalOnOpen(event);
                            try {
                                peer.dc.send(JSON.stringify(transferCompleteNotification));
                            } catch (error) {
                                console.error(`❌ Failed to send delayed completion notification to ${peerId}:`, error);
                            }
                        };
                    }
                }
            });
            
            console.log(`=== NOTIFICATION SUMMARY: Sent to ${notificationsSent}/${totalPeers} peers ===`);
            appendMessageToLog('System', 'Host transfer completed successfully!', 'System');
        }
        
        async function handleHostTransferAsJoiner(newHostName) {
            appendMessageToLog('System', `Host transfer to ${newHostName} in progress...`, 'System');
            

            let newHostConnectionFound = false;
            const newHostPeer = peerConnections.get('new_host_pending');

            if (newHostPeer && newHostPeer.dc) {
                if (newHostPeer.dc.readyState === 'open') {
                    switchToNewHost(newHostPeer, newHostName);
                    newHostConnectionFound = true;
                } else if (newHostPeer.dc.readyState === 'connecting') {
                    newHostPeer.dc.onopen = () => switchToNewHost(newHostPeer, newHostName);
                    setTimeout(() => {
                        if (newHostPeer.dc.readyState !== 'open') attemptReconnection();
                    }, 8000);
                    newHostConnectionFound = true;
                }
            }
            
            if (!newHostConnectionFound) {
                attemptReconnection();
            }
            
            function switchToNewHost(newHostPeer, newHostName) {
                const oldHostPeer = peerConnections.get('host');

                // --- FIX START ---
                // 1. Clean up the OLD host's listeners and connection completely.
                if (oldHostPeer) {
                    if (oldHostPeer.dc) {
                        oldHostPeer.dc.onmessage = null;
                        oldHostPeer.dc.onopen = null;
                        oldHostPeer.dc.onclose = null;
                    }
                    oldHostPeer.pc.onconnectionstatechange = null;
                    oldHostPeer.pc.ondatachannel = null;
                    oldHostPeer.pc.onicecandidate = null;
                    oldHostPeer.pc.close();
                    console.log("Old host connection cleaned up and closed.");
                }

                // 2. Point the permanent 'host' peerId to the new connection.
                peerConnections.set('host', newHostPeer);
                peerConnections.delete('new_host_pending');

                // 3. Re-bind all data channel events for the new host using the correct 'host' peerId.
                // This is the crucial step that ensures the 'onclose' handler will work correctly.
                console.log("Re-binding data channel events for the new host with 'host' peerId.");
                bindDataChannelEvents('host', newHostPeer.dc);

                // 4. Ensure the peer connection's state changes are also monitored correctly.
                newHostPeer.pc.onconnectionstatechange = () => updatePeerStatus('host', newHostPeer.pc.connectionState);
                // --- FIX END ---
                
                console.log('Switched to new host connection');
                appendMessageToLog('System', `Connected to new host: ${newHostName}`, 'System');
                appendMessageToLog('System', 'Previous host has left the room.', 'System');

                enableChat(true);

                if (isHostTransferInProgress) {
                    isHostTransferInProgress = false;
                    sendQueuedMessages();
                }
            }
            
            function attemptReconnection() {
                appendMessageToLog('System', 'Connection to new host failed. Reconnecting...', 'System');
                isHostTransferInProgress = false;
                peerConnections.forEach(peer => peer.pc.close());
                peerConnections.clear();
                
                setTimeout(() => {
                    if (!socket.connected) socket.connect();
                    joinRoom(currentRoom);
                }, 2000);
            }
        }

        // --- Message Handling Logic ---
        function bindDataChannelEvents(peerId, dc) {
            dc.onopen = () => {
                console.log(`Data channel opened with ${peerId}`);
                if (myRole === 'joiner' && peerId === 'host') {
                    appendMessageToLog('System', 'Request accepted! You have joined the room.', 'System');
                }
                if (myRole === 'host' && !isTransferringHost) {
                    const peerName = peerConnections.get(peerId).name;
                    participants[peerId] = { name: peerName, role: 'joiner' };
                    const welcomePayload = JSON.stringify({ type: 'welcome_info', assignedName: peerName, assignedId: peerId });
                    dc.send(welcomePayload);
                    broadcastParticipantList();
                }
                enableChat(true);
            };
            
            dc.onclose = () => {
                console.log(`Data channel closed with ${peerId}`);
                
                if (myRole === 'joiner' && peerId === 'host' && !isHostTransferInProgress && !isLeaving) {
                    alert('Connection to the host has been lost. The room is now closed.');
                    gracefulDisconnect();
                    return;
                }

                if (myRole === 'host' && !isTransferringHost) {
                    const leavingUserName = participants[peerId]?.name || 'A user';
                    delete participants[peerId];
                    peerConnections.delete(peerId);
                    appendMessageToLog('System', `${leavingUserName} has left the room.`, 'System');
                    broadcastParticipantList();
                } else {
                    peerConnections.delete(peerId);
                }
                
                if (peerConnections.size === 0 && myRole !== 'host') {
                    console.log('No more connections, disabling chat');
                    enableChat(false);
                }
            };
            
            dc.onmessage = async (event) => {
                const data = JSON.parse(event.data);
                console.log(`[onmessage] ROLE: ${myRole} | FROM: ${peerId} | RECEIVED: ${data.type}`, data);

                if (myRole === 'host') {
                    if (data.type === 'chat_to_host') {
                        messageCounter++;
                        const broadcastPayload = { type: 'chat_broadcast', message: data.message, senderId: data.senderId, senderName: participants[data.senderId].name, timestamp: messageCounter };
                        peerConnections.forEach((p, pId) => {
                            if (pId !== peerId && p.dc?.readyState === 'open') p.dc.send(JSON.stringify(broadcastPayload));
                        });
                        if (data.messageId) {
                            const senderPeer = peerConnections.get(peerId);
                            if (senderPeer?.dc?.readyState === 'open') {
                                try { senderPeer.dc.send(JSON.stringify({ type: 'message_acknowledgment', messageId: data.messageId })); } catch (error) { console.error('Failed to send acknowledgment:', error); }
                            }
                        }
                        appendMessageToLog(participants[data.senderId].name, data.message, data.senderId, 'sent');
                    } else if (data.type === 'user_leaving') {
                        console.log(`Peer ${peerId} (${participants[peerId]?.name}) is voluntarily leaving.`);
                        const peer = peerConnections.get(peerId);
                        if (peer) {
                            peer.pc.close();
                        }
                    } else if (data.type === 'request_name_change') {
                        const uniqueName = getUniqueName(data.newName);
                        participants[peerId].name = uniqueName;
                        peerConnections.get(peerId).name = uniqueName;
                        broadcastParticipantList();
                    } else if (data.type === 'offer_for_host_transfer') {
                        await handleOfferFromPeer(peerId, data.offerSdp);
                    } else if (data.type === 'answer_for_host_transfer') {
                        await handleAnswerFromNewHost(data.forPeerId, data.answerSdp);
                    }
                } else { // Joiner logic
                    if (data.type === 'chat_broadcast') {
                        if (data.senderId !== socket.id) appendMessageToLog(data.senderName, data.message, data.senderId, 'sent');
                    } else if (data.type === 'message_acknowledgment') {
                        handleMessageAcknowledgment(data.messageId);
                    } else if (data.type === 'name_change_confirmed') {
                        myName = data.newName;
                        if (data.oldName !== data.newName) appendMessageToLog('System', `Your name was changed from ${data.oldName} to ${data.newName}`, 'System');
                    } else if (data.type === 'user_list_update') {
                        participants = data.list;
                        if(participants[socket.id]) myName = participants[socket.id].name;
                        renderParticipantList();
                        if (!isInitialJoinerSetupComplete) {
                            console.log('Initial setup complete. Disconnecting from signaling server.');
                            appendMessageToLog('System', 'P2P connection established. Disconnected from signaling server.', 'System');
                            socket.disconnect();
                            isInitialJoinerSetupComplete = true;
                        }
                    } else if (data.type === 'welcome_info') {
                        myName = data.assignedName;
                        myAssignedId = data.assignedId;
                        console.log(`Received my ID from host: ${myAssignedId}`);
                    } else if (data.type === 'host_transfer_starting') {
                        isHostTransferInProgress = true;
                        appendMessageToLog('System', `Host transfer starting. Messages will be queued...`, 'System');
                    } else if (data.type === 'host_transfer_announcement') {
                        appendMessageToLog('System', `Host is being transferred to ${data.newHostName}...`, 'System');
                        if (data.participants) participants = data.participants;
                    } else if (data.type === 'host_transfer_completed') {
                        isHostTransferInProgress = false;
                        appendMessageToLog('System', `Host transfer to ${data.newHostName} completed!`, 'System');
                        setTimeout(() => { sendQueuedMessages(); }, 1000);
                    } else if (data.type === 'request_new_offer_for_host_transfer') {
                        const pc = new RTCPeerConnection(configuration);
                        const dc = pc.createDataChannel('chat');
                        bindDataChannelEvents('new_host_pending', dc);
                        const offer = await pc.createOffer();
                        await pc.setLocalDescription(offer);
                        await new Promise(resolve => { pc.onicegatheringstatechange = () => (pc.iceGatheringState === 'complete') && resolve(); });
                        peerConnections.set('new_host_pending', { pc, dc, name: 'New Host' });
                        const response = { type: 'offer_for_host_transfer', offerSdp: pc.localDescription };
                        peerConnections.get('host')?.dc?.send(JSON.stringify(response));
                    } else if (data.type === 'forwarded_answer_for_host_transfer') {
                        const pendingPeer = peerConnections.get('new_host_pending');
                        if (pendingPeer) await pendingPeer.pc.setRemoteDescription(new RTCSessionDescription(data.answerSdp));
                    } else if (data.type === 'host_transfer_finalized') {
                        handleHostTransferAsJoiner(data.newHostName);
                    } else if (data.type === 'final_participant_update') {
                        if (data.oldHostLeft) {
                            participants = data.participants;
                            renderParticipantList();
                        }
                    } else if (data.type === 'forwarded_offer_for_host_transfer') {
                        const pc = new RTCPeerConnection(configuration);
                        pc.ondatachannel = event => {
                            const newDc = event.channel;
                            peerConnections.set(data.fromPeerId, { pc, dc: newDc, name: data.fromPeerName || 'Unknown' });
                            bindDataChannelEvents(data.fromPeerId, newDc);
                            if (!participants[data.fromPeerId]) participants[data.fromPeerId] = { name: data.fromPeerName || 'Unknown', role: 'joiner' };
                        };
                        await pc.setRemoteDescription(new RTCSessionDescription(data.offerSdp));
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        await new Promise(resolve => { pc.onicegatheringstatechange = () => (pc.iceGatheringState === 'complete') && resolve(); });
                        const response = { type: 'answer_for_host_transfer', forPeerId: data.fromPeerId, answerSdp: pc.localDescription };
                        peerConnections.get('host')?.dc?.send(JSON.stringify(response));
                    } else if (data.type === 'host_transfer_complete') {
                        await handleHostTransferComplete(data.roomName, data.participants);
                    }
                }
            };
        }
        
        function sendChatMessage() {
            const message = DOM.chatInput.value.trim();
            if (!message) return;
            
            if (isHostTransferInProgress && myRole !== 'host') {
                messageQueue.push({ message, timestamp: Date.now() });
                appendMessageToLog(myName, message, myAssignedId, 'queued');
                appendMessageToLog('System', 'Message queued - host transfer in progress...', 'System');
                DOM.chatInput.value = '';
                return;
            }
            
            if (myRole === 'host') {
                messageCounter++;
                const broadcastPayload = { type: 'chat_broadcast', message: message, senderId: socket.id, senderName: myName, timestamp: messageCounter };
                peerConnections.forEach(peer => { if (peer.dc?.readyState === 'open') peer.dc.send(JSON.stringify(broadcastPayload)); });
                appendMessageToLog(myName, message, socket.id, 'sent');
            } else {
                messageIdCounter++;
                const messageId = `msg_${socket.id}_${messageIdCounter}`;
                const payload = { 
                    type: 'chat_to_host', 
                    message: message, 
                    senderId: myAssignedId,
                    messageId: messageId
                };
                const hostPeer = peerConnections.get('host');
                if (hostPeer?.dc?.readyState === 'open') {
                    try {
                        hostPeer.dc.send(JSON.stringify(payload));
                        const messageElement = appendMessageToLog(myName, message, myAssignedId, 'pending');
                        pendingMessages.set(messageId, { element: messageElement, timeout: setTimeout(() => markMessageAsFailed(messageId, message), 5000) });
                    } catch (error) {
                        console.error('Failed to send message:', error);
                        appendMessageToLog('System', 'Failed to send message - connection error', 'System');
                    }
                } else {
                    appendMessageToLog('System', 'Failed to send message - not connected to host. Attempting to reconnect...', 'System');
                    if (!socket.connected) socket.connect();
                    setTimeout(() => joinRoom(currentRoom), 1000);
                    return;
                }
            }
            DOM.chatInput.value = '';
        }
        
        function sendQueuedMessages() {
            if (messageQueue.length === 0) return;
            appendMessageToLog('System', `Sending ${messageQueue.length} queued messages...`, 'System');
            messageQueue.forEach((queuedMsg, index) => {
                setTimeout(() => {
                    DOM.chatInput.value = queuedMsg.message;
                    sendChatMessage();
                }, index * 100);
            });
            messageQueue = [];
        }
        
        function markMessageAsFailed(messageId, originalMessage) {
            const pendingMsg = pendingMessages.get(messageId);
            if (pendingMsg) {
                clearTimeout(pendingMsg.timeout);
                const messageElement = pendingMsg.element;
                if (messageElement) {
                    messageElement.classList.add('message-failed');
                    const retryButton = document.createElement('button');
                    retryButton.textContent = 'Retry';
                    retryButton.className = 'text-xs bg-red-600 hover:bg-red-500 text-white px-2 py-1 rounded ml-2';
                    retryButton.onclick = () => {
                        messageElement.remove();
                        DOM.chatInput.value = originalMessage;
                        sendChatMessage();
                    };
                    const bubble = messageElement.querySelector('.message-bubble');
                    if (bubble) bubble.appendChild(retryButton);
                }
                pendingMessages.delete(messageId);
            }
        }
        
        function handleMessageAcknowledgment(messageId) {
            const pendingMsg = pendingMessages.get(messageId);
            if (pendingMsg) {
                clearTimeout(pendingMsg.timeout);
                const messageElement = pendingMsg.element;
                if (messageElement) {
                    messageElement.classList.remove('message-pending');
                    messageElement.classList.add('message-sent');
                    const statusIndicator = messageElement.querySelector('.status-indicator');
                    if (statusIndicator) {
                        statusIndicator.textContent = '✓';
                        statusIndicator.className = 'status-indicator text-xs text-green-400 ml-2';
                    }
                }
                pendingMessages.delete(messageId);
            }
        }

        function appendMessageToLog(senderName, text, senderId, status = 'sent') {
            const messageContainer = document.createElement('div');
            const isSelf = (myRole === 'host' && senderId === socket.id) || (myRole === 'joiner' && senderId === myAssignedId);
            if (senderId === 'System') {
                messageContainer.className = 'chat-message message-system';
                messageContainer.innerHTML = `<span>${text}</span>`;
            } else if (isSelf) {
                messageContainer.className = `chat-message message-self message-${status}`;
                let statusIndicator = '';
                if (status === 'pending') statusIndicator = '<span class="status-indicator text-xs text-gray-400 ml-2">⏳</span>';
                else if (status === 'sent') statusIndicator = '<span class="status-indicator text-xs text-gray-400 ml-2">✓</span>';
                else if (status === 'failed') statusIndicator = '<span class="status-indicator text-xs text-red-400 ml-2">✗</span>';
                else if (status === 'queued') statusIndicator = '<span class="status-indicator text-xs text-yellow-400 ml-2">📋</span>';
                messageContainer.innerHTML = `<div class="message-bubble">${text}${statusIndicator}</div>`;
            } else {
                messageContainer.className = 'chat-message message-peer';
                messageContainer.innerHTML = `<div class="sender-name text-green-300">${senderName}</div><div class="message-bubble">${text}</div>`;
            }
            DOM.chatLog.appendChild(messageContainer);
            DOM.chatLog.scrollTop = DOM.chatLog.scrollHeight;
            return messageContainer;
        }

        // --- Host Transfer and Disconnect Logic ---
        function handleLeaveRoom() {
            isLeaving = true;
            if (myRole !== 'host') { 
                const hostPeer = peerConnections.get('host');
                if (hostPeer?.dc?.readyState === 'open') {
                    const leavingMessage = { type: 'user_leaving' };
                    hostPeer.dc.send(JSON.stringify(leavingMessage));
                }
                setTimeout(gracefulDisconnect, 500);
                return; 
            }
            
            if (Object.keys(participants).length <= 1) { 
                gracefulDisconnect(); 
                return; 
            }
            DOM.modalPeerList.innerHTML = '';
            const peers = Object.entries(participants).filter(([id]) => id !== socket.id);
            if (peers.length > 0) {
                DOM.noPeersMessage.classList.add('hidden');
                DOM.peerSelectionPanel.classList.remove('hidden');
                DOM.promoteHostBtn.disabled = false;
                peers.forEach(([id, peer]) => {
                    const peerEl = document.createElement('label');
                    peerEl.className = 'flex items-center space-x-3 p-2 bg-gray-700 rounded-md cursor-pointer hover:bg-gray-600';
                    peerEl.innerHTML = `<input type="radio" name="peer-select" value="${id}" class="form-radio h-4 w-4 text-cyan-600 bg-gray-900 border-gray-600 focus:ring-cyan-500"><span>${peer.name}</span>`;
                    DOM.modalPeerList.appendChild(peerEl);
                });
            } else {
                DOM.noPeersMessage.classList.remove('hidden');
                DOM.peerSelectionPanel.classList.add('hidden');
                DOM.promoteHostBtn.disabled = true;
            }
            DOM.hostTransferModal.classList.remove('hidden');
        }

        function promoteAndLeave() {
            const selectedPeerInput = document.querySelector('input[name="peer-select"]:checked');
            if (!selectedPeerInput) { 
                alert('Please select a user to promote to host.'); 
                return; 
            }
            const newHostSid = selectedPeerInput.value;
            DOM.hostTransferModal.classList.add('hidden');
            initiateHostTransfer(newHostSid);
        }
        
        function gracefulDisconnect() {
            isLeaving = true; 
            if (socket.connected) {
                if (myRole === 'host') {
                    socket.emit('close_room', { room_name: currentRoom });
                }
                socket.disconnect();
            }
            peerConnections.forEach(peer => peer.pc.close());
            peerConnections.clear();
            location.reload();
        }
        
        // --- Trivial Functions & Event Handlers ---
        async function fetchRooms() { 
            try { 
                if(!socket.connected) socket.connect(); 
                const res=await fetch(`${SIGNALING_SERVER_URL}/rooms`); 
                const rooms=await res.json(); 
                DOM.roomList.innerHTML=rooms.length?'':'<p class="text-gray-500">No rooms available.</p>'; 
                rooms.forEach(r=>{
                    const el=document.createElement('div'); 
                    el.className='flex items-center justify-between bg-gray-700 p-2 rounded-lg'; 
                    el.innerHTML=`<div><span class="font-semibold">${r.name}</span><span class="text-xs text-gray-400 ml-2">by ${r.owner}</span></div>`; 
                    const btn=document.createElement('button'); 
                    btn.className='text-sm bg-green-600 hover:bg-green-500 py-1 px-3 rounded-lg'; 
                    btn.textContent='Join'; 
                    btn.onclick=()=>joinRoom(r.name); 
                    el.appendChild(btn); 
                    DOM.roomList.appendChild(el);
                }); 
            } catch(e){
                console.error('Could not fetch rooms:',e); 
                DOM.roomList.innerHTML='<p class="text-red-500">Could not connect to server.</p>';
            } 
        }
        
        function enableChat(isEnabled) { 
            DOM.chatInput.disabled = !isEnabled; 
            DOM.sendChatBtn.disabled = !isEnabled;
        }
        
        function updatePeerStatus(peerId, state) { 
            if (state==='failed'||state==='closed'||state==='disconnected') { 
                const peer=peerConnections.get(peerId); 
                if(peer&&peer.dc?.readyState!=='closed')peer.dc.close();
            }
        }
        
        // --- Socket Event Handlers ---
        socket.on('connect', () => { 
            console.log('Connected to signaling server.'); 
            fetchRooms(); 
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from signaling server.');
        });
        
        socket.on('room_created', (data) => 
            data.success ? switchToMainView('host', data.room_name) : alert(`Error: ${data.message}`)
        );
        
        socket.on('room_closed', () => { 
            alert('The room has been closed by the host.'); 
            gracefulDisconnect(); 
        });
        
        socket.on('new_joiner', (data) => {
            if (myRole !== 'host') return;
            if (DOM.autoAcceptCheckbox.checked) {
                acceptJoiner(data.joiner_sid, data.joiner_name, data.offer_sdp);
                return;
            }
            if (DOM.pendingRequestsDiv.querySelector('p')) DOM.pendingRequestsDiv.innerHTML = '';
            const { joiner_sid, joiner_name, offer_sdp } = data;
            const el = document.createElement('div');
            el.id = `req-${joiner_sid}`;
            el.className = 'flex items-center justify-between bg-gray-700 p-2 rounded-lg';
            el.innerHTML = `<span class="text-sm">${joiner_name}</span>`;

            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'space-x-2';

            const acceptBtn = document.createElement('button');
            acceptBtn.className = 'text-xs bg-green-600 hover:bg-green-500 py-1 px-3 rounded-lg';
            acceptBtn.textContent = 'Accept';
            acceptBtn.onclick = () => acceptJoiner(joiner_sid, joiner_name, offer_sdp);

            const denyBtn = document.createElement('button');
            denyBtn.className = 'text-xs bg-red-600 hover:bg-red-500 py-1 px-3 rounded-lg';
            denyBtn.textContent = 'Deny';
            denyBtn.onclick = () => denyJoiner(joiner_sid, joiner_name);

            buttonContainer.appendChild(acceptBtn);
            buttonContainer.appendChild(denyBtn);
            el.appendChild(buttonContainer);
            DOM.pendingRequestsDiv.appendChild(el);
        });
        
        socket.on('owner_response', async(data)=>{
            if(myRole!=='joiner')return; 
            const p=peerConnections.get('host'); 
            if(p?.pc) await p.pc.setRemoteDescription(new RTCSessionDescription(data.answer_sdp));
        });
        
        socket.on('join_denied', () => {
            if (myRole !== 'joiner') return;
            alert('Your request to join the room was denied by the host.');
            gracefulDisconnect();
        });

        socket.on('ownership_claimed', () => {
            console.log('Successfully claimed host role on server');
        });
        
        socket.on('error', (data) => alert(`Server Error: ${data.message}`));
        
        // --- DOM Event Handlers ---
        DOM.createRoomBtn.addEventListener('click', createRoom);
        DOM.refreshRoomsBtn.addEventListener('click', fetchRooms);
        DOM.leaveRoomBtn.addEventListener('click', handleLeaveRoom);
        DOM.sendChatBtn.addEventListener('click', sendChatMessage);
        DOM.chatInput.addEventListener('keyup', (e) => { if (e.key === 'Enter') sendChatMessage(); });
        DOM.closeRoomBtn.addEventListener('click', () => { 
            DOM.hostTransferModal.classList.add('hidden'); 
            gracefulDisconnect(); 
        });
        DOM.promoteHostBtn.addEventListener('click', promoteAndLeave);
        DOM.hostTransferModal.addEventListener('click', (e) => { 
            if (e.target.id === 'host-transfer-modal') DOM.hostTransferModal.classList.add('hidden'); 
        });
        window.addEventListener('beforeunload', gracefulDisconnect);
        
        // --- INITIALIZATION ---
        fetchRooms();
    </script>
</body>
</html>
